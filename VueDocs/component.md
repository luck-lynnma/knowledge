# 基础组件
**组件是可复用的VUE实例**, 并且有一个名字,可以再`new Vue`的根实例中作为一个自定义元素来使用.因为组件是可复用的Vue实例,所以可以与`new Vue`接收相同的选项,例如`data,props,computed,watch,methods等,以及生命周期钩子`,但是没有`el`这种实例特有的选项.

组件可以复用,但是每复用一次组件就会有一个它的`实例`被创建

通常一个应用会以一颗嵌套的组件树的形式来组成

为了能在模板中使用,这些组件必须先被注册以便被Vue识别.有两种注册方式:`全局注册` 和 `局部注册`

`全局注册`的组件可以被任何`新创建的Vue根实例`以及`子组件的模板`中使用;`局部注册`的组件只在被注册的Vue实例中使用,子组件中不可用


组件命名追寻`W3C规范(字母全部小写且必须包含一个连字符)`,可以避免和当前以及未来的HTML元素冲突

## 通过Prop向子组件传递数据

Prop是组件注册的自定义的特性,当向prop特性传递数据时,prop就会变成这个组件的属性,子组件会像访问`data`中值一样访问props内属性值.组件可以拥有无数的prop

父组件可以使用`v-bind`指令来将父组件中`data`的任意数据通过`Prop`传递给子组件

每个组件必须只有一个根元素

当父组件向子组件传递数据过于复杂时,可以将数据包裹成一个对象一次性传递给子组件

## 监听子组件事件

除了父组件向子组件传递信息,父组件也可以监听子组件.

子组件可以使用内置的`$emit`来传入一个事件名称来触发一个事件

```js
/**
* 有两个参数
* @param methodName
*       方法名称
* @param args
*       方法产地参数,可以是任意类型数据,包括数组
*/
this.$emit(methodName,args)
```

父组件使用`v-on:methodName='methods'`来监听,methods会携带参数,此参数就是子组件传递过来的参数


## 通过slot分发内容
<slot>作为承载分发内容的出口.如果子组件中没有`<slot></slot>`标签,那么使用子组件时在子组件开始到子组件结束之间的内容都会丢失

### 编译作用域

使用子组件时,在子组件开始-子组件结束之间就是`编译作用域`,编译作用域中可以是父组件的数据,HTML语句,也可以显示子组件的数据(`作用域插槽`)


### 后备插槽

为插槽设置默认值

### 具名插槽
有时候需要许多插槽,便可以为slot设置一个`name`属性,那么不带`name`的插槽,默认名为`default`(也叫默认插槽/匿名插槽),父组件使用插槽时:用`v-slot`指令,将`name`值赋值给`v-slot`(例如:v-slot:slotName).任何没有被`v-slot`包裹的slot就会视为是默认slot的内容

`v-slot`也有缩写 **`#`**

>注意:v-slot只能添加在一个<template>上;默认插槽只能有一个;具名插槽可以有多个,只要name不同就可以

### 作用域插槽
`作用域插槽,也叫带数据的插槽`,子组件的<slot>上绑定数据,绑定在<slot>上的特性成为`插槽prop`
插槽内容访问子组件的数据.为了能让父组件的插槽访问子组件的数据

## 传递静态或动态Prop

传递静态值,直接使用Prop即可,但是传递动态值可以使用`v-bind`,v-bind告知Prop不是字符串,而是一个表达式.因此传递Number,Array,Object,Boolean值均使用`v-bind`

## 单向数据流
prop使父子组件之间形成了一个 **单向下行绑定**:父组件数据更新会下行到子组件的prop中,但是反过来不行,防止子组件来修改父组件的状态.父组件更新时子组件的prop也会刷新为最新值.意味着 **不能在子组件中修改prop**

2种方式来避免直接改变prop:

+ **prop传递一个初始值**,可以将prop值赋值给子组件的data,子组件使用data来操作数据

+ **prop传入原始值但是需要进行转换**.这种情况下最好使用prop定义一个计算属性

> 注意:JavaScript传递对象或数组是引用传入的,所以对于一个数组或是对象类型的prop来说,在子组件中改变这个对象或是数组本身就会影响到父组件的状态

## 非Prop的特性

一个非prop特性传入子组件,但是该子组件没有定义相应的prop,那么这个非prop特性就会被添加到该子组件的根元素上.**这也是组件可以接受任意的特性原因**

## 替换/合并已有的特性

绝大多数外部传进来的特性都会替换组件内已存在的特性,但是`style和CLASS`比较特殊,会合并内外两个特性值


## 动态组件上使用`keep-alive`

在多标签界面使用 **`is`** 来切换不同组件,每次切换组件,都会重新创建一个新的实例,有时候为了避免这种情况带来的性能问题,可以使用`<keep-alive>`将其动态组件包裹起来

```js
<!-- 失活的组件将会被缓存！-->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```
